<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Reproductor Multimedia Táctil con Gamepad</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* --- Variables --- */
        :root {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --accent-color: #1DB954; /* Spotify Green - Buen contraste */
            --error-color: #CF6679;
            --success-color: #2ECC71;
            --favorite-color: #FFD700;
            --unknown-color: #616161; /* Color para estado desconocido (gris) */
            --border-color: #333333;
            --border-radius-lg: 16px;
            --border-radius-md: 12px;
            --border-radius-sm: 8px;
            --spacing-unit: 8px;
            --header-height: 60px;
            --footer-height: 70px;
            --button-min-size: 48px; /* Tamaño mínimo táctil */
            --gamepad-focus-outline: 3px solid var(--accent-color);
            --gamepad-focus-shadow: 0 0 10px rgba(29, 185, 84, 0.8);
        }

        /* --- Estilos Globales --- */
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; /* Evitar highlight azul en tap */ }
        html, body { height: 100%; overflow: hidden; }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 16px; /* Tamaño base más grande para legibilidad */
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            -webkit-touch-callout: none; /* Deshabilitar callouts */
            -webkit-user-select: none;   /* Deshabilitar selección de texto */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* Internet Explorer/Edge */
            user-select: none;         /* Non-prefixed version */
        }

        /* --- Layout Principal --- */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh; /* Ocupar toda la altura */
        }

        /* --- Cabecera --- */
        .app-header {
            height: var(--header-height);
            background-color: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: space-between; /* Cambiado para logo y botón atrás */
            padding: 0 calc(var(--spacing-unit) * 2);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .app-header .back-button {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 24px; /* Más grande */
            cursor: pointer;
            padding: var(--spacing-unit);
            display: none; /* Oculto por defecto */
            min-width: var(--button-min-size);
            min-height: var(--button-min-size);
            align-items: center;
            justify-content: center;
        }
         .app-header .back-button.visible {
           display: flex; /* Mostrar cuando sea necesario */
         }
        .app-header .logo img {
            height: 40px;
            object-fit: contain;
            margin: 0 auto; /* Centrar logo si no hay botón atrás */
        }
        .app-header .logo.with-back-button img {
            margin: 0; /* Alinear a la izquierda cuando hay botón atrás */
        }
        .header-spacer {
            width: var(--button-min-size);
            height: var(--button-min-size);
            flex-shrink: 0;
        }

        /* --- Contenido Principal --- */
        .app-main {
            flex-grow: 1;
            overflow-y: auto; /* Scroll principal */
            overflow-x: hidden;
            position: relative; /* Para el overlay de carga */
        }
        .app-main::-webkit-scrollbar { width: 6px; }
        .app-main::-webkit-scrollbar-track { background: transparent; }
        .app-main::-webkit-scrollbar-thumb { background-color: var(--bg-tertiary); border-radius: 3px; }

        /* --- Vistas (Secciones) --- */
        .view {
            display: none;
            padding: calc(var(--spacing-unit) * 2);
            height: 100%;
            overflow-y: auto;
        }
        .view.active { display: block; }

        /* --- Vista Menú Principal --- */
        #mainMenuView {
            background-image: url('https://d2t1xqejof9utc.cloudfront.net/screenshots/pics/5a713433010f81e5b52534d932f73905/large.png');
            background-size: 80% auto;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
            z-index: 1;
            background-color: var(--bg-primary);
        }
        #mainMenuView::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: -1;
            border-radius: inherit;
        }
        #mainMenuView .menu-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: calc(var(--spacing-unit) * 2);
            padding: calc(var(--spacing-unit) * 2) 0;
            position: relative;
            z-index: 2;
        }
        .menu-button {
            background-color: rgba(30, 30, 30, 0.8);
            border: 1px solid rgba(51, 51, 51, 0.8);
            color: var(--text-primary);
            padding: calc(var(--spacing-unit) * 3) calc(var(--spacing-unit) * 2);
            border-radius: var(--border-radius-md);
            font-size: 1.2em;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease, outline 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-unit);
            min-height: 120px;
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
        }
        .menu-button i {
            font-size: 2em;
            margin-bottom: var(--spacing-unit);
        }
        .menu-button:hover { background-color: rgba(42, 42, 42, 0.9); }
        .menu-button:active { transform: scale(0.97); }

        /* --- Vista Lista de Contenido --- */
        .content-list-view h2 {
            font-size: 1.5em;
            margin-bottom: calc(var(--spacing-unit) * 2);
            color: var(--text-primary);
        }
        .search-bar {
            display: flex;
            margin-bottom: calc(var(--spacing-unit) * 2);
        }
        .search-bar input {
            flex-grow: 1;
            padding: calc(var(--spacing-unit) * 1.5);
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm) 0 0 var(--border-radius-sm);
            color: var(--text-primary);
            font-size: 1em;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .search-bar input:focus { border-color: var(--accent-color); }
        .search-bar button {
            padding: 0 calc(var(--spacing-unit) * 2);
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-left: none;
            border-radius: 0 var(--border-radius-sm) var(--border-radius-sm) 0;
            color: var(--text-secondary);
            font-size: 1.2em;
            cursor: pointer;
            min-width: var(--button-min-size);
            transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease, outline 0.2s ease;
        }
        .search-bar button:hover { background-color: var(--border-color); color: var(--text-primary); }

        /* Grid Común */
        .item-grid, .channel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: calc(var(--spacing-unit) * 1.5);
        }
        .item-card {
            background-color: var(--bg-secondary);
            border-radius: var(--border-radius-sm);
            overflow: hidden;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease, outline 0.2s ease;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .item-card:hover { background-color: var(--bg-tertiary); }
        .item-card:active { transform: scale(0.97); }
        .item-card .card-image-container {
            position: relative;
            width: 100%;
            background-color: var(--bg-tertiary);
        }
        .item-card.series-card img, .item-card.movie-card img { aspect-ratio: 2 / 3; }
        .item-card.tv-card img {
            aspect-ratio: 1 / 1;
            object-fit: cover;
            border-radius: 50%;
            padding: 10%;
            background-color: var(--bg-tertiary);
        }
        .item-card img { width: 100%; height: auto; display: block; }
        .item-card .text-content {
            padding: var(--spacing-unit);
            text-align: center;
            flex-grow: 1;
        }
        .item-card h3 {
            font-size: 0.9em;
            font-weight: 500;
            color: var(--text-primary);
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            min-height: calc(1.3em * 2);
        }
        .item-card p { display: none; }
        .item-card.tv-card .status-dot {
            position: absolute;
            bottom: calc(10% + 4px);
            right: calc(10% + 4px);
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--unknown-color);
            border: 2px solid var(--bg-secondary);
            transition: background-color 0.3s ease;
            z-index: 2;
        }
        .item-card.tv-card .status-dot.online { background-color: var(--success-color); }
        .item-card.tv-card .status-dot.offline { background-color: var(--error-color); }
        .item-card.active { /* Estilo para el canal/contenido actualmente SELECCIONADO o REPRODUCIÉNDOSE */
            outline: 2px solid var(--accent-color);
            outline-offset: -2px;
            background-color: var(--bg-tertiary);
        }

        /* --- Estilo de Foco para Gamepad --- */
        .gamepad-focus {
            outline: var(--gamepad-focus-outline) !important;
            outline-offset: 2px;
            box-shadow: var(--gamepad-focus-shadow) !important;
        }
        /* Asegurar que los selectores también muestren foco */
        select.gamepad-focus {
             border-color: var(--accent-color) !important;
        }


        /* Vista Reproductor */
        #playerView {
            height: 100%; display: flex; flex-direction: column; padding: 0; overflow: hidden;
        }
        .player-area {
            flex-grow: 1; background-color: #000; position: relative; display: flex;
            align-items: center; justify-content: center; border-radius: 0; overflow: hidden;
        }
        .player-area video, .player-area iframe { width: 100%; height: 100%; display: block; border: none; }
        .player-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: var(--text-secondary); background-color: rgba(0,0,0,0.7);
            padding: var(--spacing-unit) calc(var(--spacing-unit) * 2); border-radius: var(--border-radius-sm);
            text-align: center;
        }
        .player-info-controls {
            padding: calc(var(--spacing-unit) * 1.5); flex-shrink: 0; display: flex;
            flex-direction: column; gap: var(--spacing-unit); background-color: var(--bg-primary);
        }
        .content-info h3 { font-size: 1.2em; font-weight: 500; margin-bottom: calc(var(--spacing-unit) * 0.5); }
        .content-info p {
            font-size: 0.9em; color: var(--text-secondary); display: -webkit-box;
            -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis;
        }
        .specific-controls { display: flex; align-items: center; gap: var(--spacing-unit); flex-wrap: wrap; }
        .favorite-button {
            background-color: var(--bg-secondary); border: 1px solid var(--border-color);
            color: var(--text-secondary); font-size: 1.5em; border-radius: 50%; cursor: pointer;
            width: var(--button-min-size); height: var(--button-min-size); display: flex;
            align-items: center; justify-content: center;
            transition: color 0.2s ease, background-color 0.2s ease, box-shadow 0.2s ease, outline 0.2s ease;
        }
        .favorite-button.is-favorite { color: var(--favorite-color); background-color: var(--bg-tertiary); }
        .favorite-button:hover { background-color: var(--bg-tertiary); }
        .favorite-button:active { transform: scale(0.95); }
        .season-episode-selectors { display: flex; gap: var(--spacing-unit); flex-wrap: wrap; }
        .season-episode-selectors select {
            background-color: var(--bg-secondary); border: 1px solid var(--border-color);
            color: var(--text-primary); padding: calc(var(--spacing-unit) * 1.2) calc(var(--spacing-unit) * 1.5);
            border-radius: var(--border-radius-sm); font-size: 1em; min-width: 120px;
            cursor: pointer; outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .season-episode-selectors select:focus { border-color: var(--accent-color); }

        /* Overlays */
        .loading-overlay, .error-overlay-car {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8); display: none; align-items: center;
            justify-content: center; z-index: 1500; padding: calc(var(--spacing-unit) * 3);
            text-align: center; flex-direction: column;
        }
        .loading-overlay.visible, .error-overlay-car.visible { display: flex; }
        .spinner {
            border: 4px solid var(--bg-tertiary); border-top: 4px solid var(--accent-color);
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin-bottom: var(--spacing-unit);
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .error-overlay-car .error-message {
            color: var(--error-color); font-size: 1.1em; margin-bottom: calc(var(--spacing-unit) * 2);
        }
        .error-overlay-car .error-buttons { display: flex; gap: var(--spacing-unit); flex-wrap: wrap; justify-content: center; }
        .error-overlay-car .error-button {
            background-color: var(--bg-tertiary); border: 1px solid var(--border-color);
            color: var(--text-primary); padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
            border-radius: var(--border-radius-sm); cursor: pointer; font-size: 0.9em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, outline 0.2s ease;
        }
        .error-overlay-car .error-button:hover { background-color: var(--border-color); }

        /* Responsividad */
        @media (max-width: 600px) {
            :root {
                --header-height: 50px; --footer-height: 60px; --spacing-unit: 6px; --button-min-size: 44px;
            }
            body { font-size: 15px; }
            .app-header .logo img { height: 35px; }
            #mainMenuView .menu-grid { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: var(--spacing-unit); }
            .menu-button { padding: calc(var(--spacing-unit) * 2); font-size: 1.1em; min-height: 100px; }
            .menu-button i { font-size: 1.8em; }
            .item-grid, .channel-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: var(--spacing-unit); }
            .item-card h3 { font-size: 0.85em; min-height: calc(1.3em * 2); }
            .content-info h3 { font-size: 1.1em; }
            .content-info p { font-size: 0.85em; }
            .season-episode-selectors select { font-size: 0.9em; min-width: 100px; padding: var(--spacing-unit); }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <button class="back-button" id="backButton" aria-label="Volver" tabindex="-1">
                <i class="fas fa-arrow-left"></i>
            </button>
            <div class="logo" id="logoContainer">
                 <img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjtH1eFwNcBk9FvfM8ozeG6zjDtvJR2j2CdfNtfn8rj0JP9PRWR7zeL_ayD_dwmmuqOe8-sTp-TcOGCVsg5yhUNBO_PqRVI9gCMu3B1x2MQ1ZsitAg-1NKxQ70x3H-O9eehSCsQO6DzLPxcB_uZpfGmfziYNcXQ0JylvrGY1PE-sc9nJ76l2c62PG3Kcvs/w683-h203/JORGEDEZ-19-3-2025.png"
                     alt="Logo JORGEDEZ"
                     onerror="this.onerror=null; this.style.display='none';">
            </div>
            <div class="header-spacer"></div>
        </header>

        <main class="app-main">
            <div id="mainMenuView" class="view active">
                <div class="menu-grid">
                    <button class="menu-button" data-target-view="tvListView" tabindex="0">
                        <i class="fas fa-tv"></i>
                        <span>TV en Vivo</span>
                    </button>
                    <button class="menu-button" data-target-view="seriesListView" tabindex="0">
                        <i class="fas fa-video"></i>
                        <span>Series</span>
                    </button>
                    <button class="menu-button" data-target-view="moviesListView" tabindex="0">
                        <i class="fas fa-film"></i>
                        <span>Películas</span>
                    </button>
                    <button class="menu-button" data-target-view="favoritesListView" tabindex="0">
                        <i class="fas fa-star"></i>
                        <span>Favoritos (TV)</span>
                    </button>
                </div>
            </div>

            <div id="tvListView" class="view content-list-view">
                <h2>TV en Vivo</h2>
                <div class="search-bar">
                    <input type="text" id="tvSearchInput" placeholder="Buscar canal..." aria-label="Buscar canal de TV" tabindex="0">
                    <button id="tvSearchButton" aria-label="Buscar" tabindex="0"><i class="fas fa-search"></i></button>
                </div>
                <div class="channel-grid" id="tvChannelList">
                    </div>
            </div>

            <div id="seriesListView" class="view content-list-view">
                <h2>Series</h2>
                <div class="item-grid" id="seriesGrid">
                    </div>
            </div>

            <div id="moviesListView" class="view content-list-view">
                <h2>Películas</h2>
                <div class="item-grid" id="moviesGrid">
                    </div>
            </div>

            <div id="favoritesListView" class="view content-list-view">
                <h2>Favoritos (TV)</h2>
                 <div class="channel-grid" id="favoritesChannelList">
                    </div>
            </div>

            <div id="playerView" class="view">
                <div class="player-area">
                    <video id="hlsPlayer" playsinline webkit-playsinline crossorigin="anonymous" controls style="display: none;" tabindex="-1"></video>
                    <iframe id="drivePlayer" src="about:blank" allow="autoplay; fullscreen" style="display: none;" tabindex="-1"></iframe>
                    <div class="player-message" id="playerMessageElement">Cargando...</div>
                </div>
                <div class="player-info-controls">
                    <div class="content-info">
                        <h3 id="playerContentTitle">Título</h3>
                        <p id="playerContentDescription">Descripción...</p>
                    </div>
                    <div class="specific-controls">
                        <button id="playerFavoriteButton" class="favorite-button" aria-label="Añadir a favoritos" style="display: none;" tabindex="0">
                            <i class="fas fa-star"></i>
                        </button>
                        <div id="playerSeriesSelectors" class="season-episode-selectors" style="display: none;">
                            <select id="seasonSelector" aria-label="Seleccionar temporada" tabindex="0"></select>
                            <select id="episodeSelector" aria-label="Seleccionar episodio" tabindex="0"></select>
                        </div>
                    </div>
                </div>
            </div>

            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>
                <span id="loadingMessage">Cargando...</span>
            </div>

        </main>

         </div>

    <div class="error-overlay-car" id="errorOverlayCar">
        <div class="error-message" id="errorMessageCar">Error</div>
        <div class="error-buttons" id="errorButtonsCar">
            <button class="error-button" id="closeErrorCarButton" tabindex="0">Cerrar</button>
        </div>
    </div>

    <script>
    // Envolver en try...catch global
    try {
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Cargado - Reproductor Táctil con Gamepad");

            // --- URLs de Datos ---
            const M3U_URL = 'https://raw.githubusercontent.com/sejo48/chanejorgedez/refs/heads/main/listaoficial.m3u';
            const SERIES_JSON_URL = "https://raw.githubusercontent.com/sejo48/jorgedrive/refs/heads/main/playlist.json";
            const MOVIES_JSON_URL = "https://raw.githubusercontent.com/sejo48/peliculas/refs/heads/main/peliculas.json";

            // --- Estado de la Aplicación ---
            let currentView = 'mainMenuView';
            let previousView = null;
            let tvChannels = [];
            let seriesData = [];
            let moviesData = [];
            let tvFavorites = JSON.parse(localStorage.getItem('favoritesTvChannelsCar') || '[]');
            let tvChannelStatuses = JSON.parse(localStorage.getItem('channelStatusesTvPlayerCar') || '{}');
            let hlsInstance = null;
            let currentPlayingTvChannelIndex = null;
            let currentPlayingSeries = null;
            let currentPlayingMovieIndex = null;

            // --- Estado del Gamepad ---
            let activeGamepadIndex = null;
            let gamepadFocusedElement = null;
            let focusableElementsInView = [];
            let gamepadPollInterval = null;
            const GAMEPAD_BUTTON_ACTION = 0; // Generalmente 'A' o botón inferior
            const GAMEPAD_BUTTON_BACK = 1;   // Generalmente 'B' o botón derecho
            const GAMEPAD_AXIS_THRESHOLD = 0.5;
            const GAMEPAD_POLL_RATE = 100; // ms
            let lastGamepadButtonStates = [];
            let lastGamepadAxisStates = [[0,0],[0,0]]; // [LX, LY], [RX, RY]

            // --- Referencias a Elementos DOM ---
            // (Se mantienen las referencias existentes)
            const views = {
                mainMenuView: document.getElementById('mainMenuView'),
                tvListView: document.getElementById('tvListView'),
                seriesListView: document.getElementById('seriesListView'),
                moviesListView: document.getElementById('moviesListView'),
                favoritesListView: document.getElementById('favoritesListView'),
                playerView: document.getElementById('playerView'),
            };
            const backButton = document.getElementById('backButton');
            const logoContainer = document.getElementById('logoContainer');
            const tvChannelGridElement = document.getElementById('tvChannelList');
            const tvSearchInput = document.getElementById('tvSearchInput');
            const tvSearchButton = document.getElementById('tvSearchButton');
            const seriesGridElement = document.getElementById('seriesGrid');
            const moviesGridElement = document.getElementById('moviesGrid');
            const favoritesChannelGridElement = document.getElementById('favoritesChannelList');
            const hlsPlayerElement = document.getElementById('hlsPlayer');
            const drivePlayerElement = document.getElementById('drivePlayer');
            const playerMessageElement = document.getElementById('playerMessageElement');
            const playerContentTitle = document.getElementById('playerContentTitle');
            const playerContentDescription = document.getElementById('playerContentDescription');
            const playerFavoriteButton = document.getElementById('playerFavoriteButton');
            const playerSeriesSelectors = document.getElementById('playerSeriesSelectors');
            const seasonSelector = document.getElementById('seasonSelector');
            const episodeSelector = document.getElementById('episodeSelector');
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingMessage = document.getElementById('loadingMessage');
            const errorOverlayCar = document.getElementById('errorOverlayCar');
            const errorMessageCar = document.getElementById('errorMessageCar');
            const errorButtonsCarContainer = document.getElementById('errorButtonsCar'); // Renombrado para claridad
            const closeErrorCarButton = document.getElementById('closeErrorCarButton');


            if (!backButton || !logoContainer || !tvChannelGridElement || !seriesGridElement || !moviesGridElement || !favoritesChannelGridElement || !hlsPlayerElement || !drivePlayerElement || !playerMessageElement || !loadingOverlay || !errorOverlayCar || !Object.values(views).every(v => v)) {
                console.error("Error crítico: Faltan elementos esenciales de la interfaz.");
                alert("Error al cargar la interfaz. Faltan elementos."); // Considerar reemplazar alert si es posible
                return;
            }

            // --- Lógica de Navegación (Modificada para Gamepad) ---
            function navigateTo(viewId, data = null) {
                console.log(`Navegando a: ${viewId}`);
                const targetViewElement = document.getElementById(viewId);
                if (!targetViewElement) {
                     console.error(`Vista con ID ${viewId} no encontrada.`);
                     return;
                }

                previousView = currentView;
                currentView = viewId;

                document.querySelectorAll('.view').forEach(view => view.classList.remove('active'));
                targetViewElement.classList.add('active');

                if (viewId === 'mainMenuView') {
                    backButton.classList.remove('visible');
                    logoContainer.classList.remove('with-back-button');
                } else {
                    backButton.classList.add('visible');
                    logoContainer.classList.add('with-back-button');
                }

                if (previousView === 'playerView' && viewId !== 'playerView') {
                    stopPlayback();
                }

                switch (viewId) {
                    case 'tvListView':
                        if (tvChannels.length === 0) loadTvChannels().then(updateFocusableElementsForCurrentView);
                        else { renderTvChannelList(tvChannels); updateFocusableElementsForCurrentView(); }
                        break;
                    case 'seriesListView':
                        if (seriesData.length === 0) loadSeries().then(updateFocusableElementsForCurrentView);
                        else { renderSeriesList(seriesData); updateFocusableElementsForCurrentView(); }
                        break;
                    case 'moviesListView':
                        if (moviesData.length === 0) loadMovies().then(updateFocusableElementsForCurrentView);
                        else { renderMoviesList(moviesData); updateFocusableElementsForCurrentView(); }
                        break;
                    case 'favoritesListView':
                        renderFavoritesList();
                        updateFocusableElementsForCurrentView();
                        break;
                    case 'playerView':
                        if (data) setupPlayerView(data); // setupPlayerView llamará a updateFocusable...
                        break;
                    default:
                        updateFocusableElementsForCurrentView(); // Para mainMenuView y otros
                }
                document.querySelector('.app-main')?.scrollTo(0, 0);
            }

            // --- Lógica de Carga y Renderizado (Sin cambios mayores, pero las funciones de renderizado ahora añaden tabindex) ---
            function showLoading(message = "Cargando...") { /* ... (sin cambios) ... */ }
            function hideLoading() { /* ... (sin cambios) ... */ }
            function showError(message, buttonsConfig = []) {
                console.error("Mostrando error:", message);
                if (errorOverlayCar && errorMessageCar && errorButtonsCarContainer) {
                    errorMessageCar.textContent = message;
                    // Limpiar botones adicionales, mantener el de cerrar
                    while (errorButtonsCarContainer.firstChild && errorButtonsCarContainer.firstChild !== closeErrorCarButton) {
                        errorButtonsCarContainer.removeChild(errorButtonsCarContainer.firstChild);
                    }
                    buttonsConfig.forEach(config => {
                        const button = document.createElement('button');
                        button.className = 'error-button';
                        button.textContent = config.text;
                        button.tabIndex = 0; // Hacerlo enfocable
                        button.onclick = () => {
                            hideError();
                            if (config.action) config.action();
                        };
                        errorButtonsCarContainer.insertBefore(button, closeErrorCarButton);
                    });
                    errorOverlayCar.classList.add('visible');
                    updateFocusableElementsForCurrentView(); // Actualizar foco para el overlay
                } else {
                    alert(`Error: ${message}`);
                }
            }
            function hideError() {
                if (errorOverlayCar) {
                    errorOverlayCar.classList.remove('visible');
                }
                // Devolver el foco a la vista anterior o principal si es posible
                if (previousView && views[previousView]) {
                    updateFocusableElementsForCurrentView(previousView);
                } else {
                    updateFocusableElementsForCurrentView('mainMenuView');
                }
            }


            // --- TV (Modificado para añadir tabindex y actualizar foco) ---
            async function loadTvChannels() {
                showLoading("Cargando canales de TV...");
                try {
                    const response = await fetch(M3U_URL, { cache: "no-store" });
                    if (!response.ok) throw new Error(`Error HTTP ${response.status}`);
                    const m3uText = await response.text();
                    tvChannels = parseM3U(m3uText);
                    if (tvChannels.length === 0) {
                         showError("No se encontraron canales de TV válidos en la lista.", [{ text: "Recargar", action: loadTvChannels }]);
                    } else {
                         renderTvChannelList(tvChannels);
                    }
                } catch (error) {
                    showError(`Error al cargar canales: ${error.message}`, [{ text: "Reintentar", action: loadTvChannels }]);
                    tvChannels = [];
                    renderTvChannelList([]);
                } finally {
                    hideLoading();
                }
            }
            function parseM3U(m3uText) { /* ... (sin cambios en la lógica interna) ... */
                const lines = m3uText.split(/[\r\n]+/);
                const parsedChannels = [];
                let currentChannelInfo = null;
                const extinfRegex = /#EXTINF:(-?\d+)(.*)/;
                const attributeRegex = /(\S+?)=(?:"([^"]*)"|([^ ]*))/g;
                const titleCommaRegex = /,(?!")(.*)/;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine || trimmedLine === '#EXTM3U') continue;

                    if (trimmedLine.startsWith('#EXTINF:')) {
                        const match = trimmedLine.match(extinfRegex);
                        if (match) {
                            currentChannelInfo = { duration: match[1], attributes: {}, title: '', logo: '', url: '', description: '' };
                            const restOfLine = match[2] || '';
                            let attrMatch;
                            while ((attrMatch = attributeRegex.exec(restOfLine)) !== null) {
                                currentChannelInfo.attributes[attrMatch[1].toLowerCase()] = attrMatch[2] !== undefined ? attrMatch[2] : attrMatch[3];
                            }
                            currentChannelInfo.title = (currentChannelInfo.attributes['tvg-name'] || '').trim();
                            if (!currentChannelInfo.title) {
                                const titleMatch = restOfLine.match(titleCommaRegex);
                                if (titleMatch && titleMatch[1]) {
                                    currentChannelInfo.title = titleMatch[1].trim();
                                }
                            }
                            if (!currentChannelInfo.title) { currentChannelInfo.title = 'Canal Desconocido'; }
                            currentChannelInfo.logo = currentChannelInfo.attributes['tvg-logo'] || '';
                            currentChannelInfo.description = currentChannelInfo.attributes['group-title'] || currentChannelInfo.title || '';
                        } else {
                            currentChannelInfo = null;
                        }
                    } else if (currentChannelInfo && !trimmedLine.startsWith('#')) {
                        currentChannelInfo.url = trimmedLine;
                        if (currentChannelInfo.url) {
                            parsedChannels.push(currentChannelInfo);
                        }
                        currentChannelInfo = null;
                    }
                }
                return parsedChannels;
            }

            function renderTvChannelList(channelsToRender, targetElement = tvChannelGridElement) {
                if (!targetElement) return;
                targetElement.innerHTML = '';

                if (!channelsToRender || channelsToRender.length === 0) {
                    const messageElement = document.createElement('p');
                    messageElement.textContent = targetElement === favoritesChannelGridElement ? 'No hay favoritos.' : 'No se encontraron canales.';
                    messageElement.style.cssText = "color: var(--text-secondary); text-align: center; grid-column: 1 / -1; padding: calc(var(--spacing-unit) * 4) 0;";
                    targetElement.appendChild(messageElement);
                    return;
                }
                // ... (resto de la lógica de ordenación)
                const sortedChannels = [...channelsToRender].sort((a, b) => {
                    const aIndex = tvChannels.findIndex(ch => ch.url === a.url);
                    const bIndex = tvChannels.findIndex(ch => ch.url === b.url);
                    const aIsFavorite = tvFavorites.includes(aIndex.toString());
                    const bIsFavorite = tvFavorites.includes(bIndex.toString());

                    if (targetElement !== favoritesChannelGridElement) {
                        if (aIsFavorite && !bIsFavorite) return -1;
                        if (!aIsFavorite && bIsFavorite) return 1;
                    }
                    return (a.title || '').localeCompare(b.title || '');
                });


                const fragment = document.createDocumentFragment();
                sortedChannels.forEach(channel => {
                    const originalIndex = tvChannels.findIndex(ch => ch.url === channel.url);
                    if (originalIndex === -1) return;

                    const card = document.createElement('div');
                    card.className = 'item-card tv-card';
                    card.dataset.channelIndex = originalIndex;
                    card.tabIndex = 0; // Hacer la tarjeta enfocable

                    // ... (creación de img, statusDot, textContent como antes) ...
                     const imageContainer = document.createElement('div');
                    imageContainer.className = 'card-image-container';

                    const img = document.createElement('img');
                    const placeholderText = encodeURIComponent((channel.title || '?').charAt(0));
                    img.src = channel.logo || `https://placehold.co/100x100/383838/aaaaaa?text=${placeholderText}`;
                    img.alt = ''; 
                    img.onerror = () => { img.src = `https://placehold.co/100x100/383838/aaaaaa?text=${placeholderText}`; img.alt = `Placeholder ${channel.title || 'Canal'}`; };
                    img.loading = 'lazy';

                    const statusDot = document.createElement('span');
                    const currentStatus = tvChannelStatuses[originalIndex];
                    statusDot.className = `status-dot ${currentStatus || ''}`;
                    const statusTitle = currentStatus === 'online' ? 'En línea' : currentStatus === 'offline' ? 'Fuera de línea' : 'Estado desconocido';
                    statusDot.title = statusTitle;

                    imageContainer.appendChild(img);
                    imageContainer.appendChild(statusDot); 

                    const textContent = document.createElement('div');
                    textContent.className = 'text-content';
                    const title = document.createElement('h3');
                    title.textContent = channel.title || 'Canal sin título';
                    textContent.appendChild(title);

                    card.appendChild(imageContainer);
                    card.appendChild(textContent);

                    card.addEventListener('click', () => {
                        navigateTo('playerView', { type: 'tv', index: originalIndex });
                    });
                    fragment.appendChild(card);
                });
                targetElement.appendChild(fragment);

                if (currentPlayingTvChannelIndex !== null) {
                     highlightPlayingChannel(currentPlayingTvChannelIndex, targetElement);
                }
                // No llamar a updateFocusableElementsForCurrentView aquí, se llama después de renderizar en navigateTo
            }
            function renderFavoritesList() {
                const favoriteChannelsData = tvChannels.filter((channel, index) => tvFavorites.includes(index.toString()));
                renderTvChannelList(favoriteChannelsData, favoritesChannelGridElement);
            }
            function filterAndRenderTvChannels() {
                const searchTerm = tvSearchInput.value.toLowerCase().trim();
                const filtered = tvChannels.filter(channel =>
                    (channel.title && channel.title.toLowerCase().includes(searchTerm)) ||
                    (channel.description && channel.description.toLowerCase().includes(searchTerm))
                );
                renderTvChannelList(filtered, tvChannelGridElement);
                updateFocusableElementsForCurrentView(); // Actualizar foco después de filtrar
            }
            function updateTvChannelStatus(index, status) { /* ... (sin cambios) ... */ }
            function updateStatusDotInElement(gridElement, index, status) { /* ... (sin cambios) ... */ }
            function highlightPlayingChannel(index, gridElement) { /* ... (sin cambios) ... */ }


            // --- Series y Películas (Modificado para añadir tabindex y actualizar foco) ---
            async function loadSeries() {
                showLoading("Cargando series...");
                seriesGridElement.innerHTML = '';
                try {
                    const response = await fetch(SERIES_JSON_URL, { cache: "no-store", headers: { 'Accept': 'application/json' } });
                    if (!response.ok) throw new Error(`Error HTTP ${response.status}`);
                    let data = await response.json();
                    if (!Array.isArray(data)) throw new Error("Formato de datos de series inválido.");
                    seriesData = data.filter(item => item && item.tituloSerie && !item.tituloSerie.toLowerCase().includes('película') && item.tituloSerie !== 'Encanto');
                    renderSeriesList(seriesData);
                     if (seriesData.length === 0) {
                         seriesGridElement.innerHTML = `<p class="text-center" style="color: var(--text-secondary); grid-column: 1 / -1;">No hay series disponibles.</p>`;
                     }
                } catch (error) {
                    showError(`Error al cargar series: ${error.message}`, [{ text: "Reintentar", action: loadSeries }]);
                    seriesData = []; renderSeriesList([]);
                } finally { hideLoading(); }
            }
            function renderSeriesList(seriesArray) {
                if (!seriesGridElement) return;
                seriesGridElement.innerHTML = '';
                if (!seriesArray || seriesArray.length === 0) { /* ... (mensaje de no disponibles) ... */ return; }
                const fragment = document.createDocumentFragment();
                seriesArray.forEach((serie, index) => {
                    if (!serie || !serie.tituloSerie) return;
                    const card = document.createElement('div');
                    card.className = 'item-card series-card';
                    card.dataset.seriesIndex = index;
                    card.tabIndex = 0; // Enfocable

                    // ... (creación de img, textContent como antes) ...
                    const imageContainer = document.createElement('div');
                    imageContainer.className = 'card-image-container';
                    const img = document.createElement('img');
                    const placeholderText = encodeURIComponent((serie.tituloSerie || '?').charAt(0));
                    img.src = serie.imagen || `https://placehold.co/200x300/383838/aaaaaa?text=${placeholderText}`;
                    img.alt = '';
                    img.onerror = () => { img.src = `https://placehold.co/200x300/383838/aaaaaa?text=${placeholderText}`; img.alt = `Placeholder ${serie.tituloSerie}`; };
                    img.loading = 'lazy';
                    imageContainer.appendChild(img);
                    const textContent = document.createElement('div');
                    textContent.className = 'text-content';
                    const title = document.createElement('h3');
                    title.textContent = serie.tituloSerie;
                    textContent.appendChild(title);
                    card.appendChild(imageContainer);
                    card.appendChild(textContent);

                    card.addEventListener('click', () => navigateTo('playerView', { type: 'series', index: index }));
                    fragment.appendChild(card);
                });
                seriesGridElement.appendChild(fragment);
            }
            async function loadMovies() {
                showLoading("Cargando películas...");
                moviesGridElement.innerHTML = '';
                try {
                    const response = await fetch(MOVIES_JSON_URL, { cache: "no-store", headers: { 'Accept': 'application/json' } });
                    if (!response.ok) throw new Error(`Error HTTP ${response.status}`);
                    let data = await response.json();
                    if (!Array.isArray(data)) throw new Error("Formato de datos de películas inválido.");
                    moviesData = data;
                    renderMoviesList(moviesData);
                     if (moviesData.length === 0) { /* ... (mensaje de no disponibles) ... */ }
                } catch (error) {
                    showError(`Error al cargar películas: ${error.message}`, [{ text: "Reintentar", action: loadMovies }]);
                    moviesData = []; renderMoviesList([]);
                } finally { hideLoading(); }
            }
            function renderMoviesList(moviesArray) {
                if (!moviesGridElement) return;
                moviesGridElement.innerHTML = '';
                if (!moviesArray || moviesArray.length === 0) { /* ... (mensaje de no disponibles) ... */ return; }
                const fragment = document.createDocumentFragment();
                moviesArray.forEach((movie, index) => {
                    if (!movie || !movie.titulo || !movie.urlDrive) return;
                    const card = document.createElement('div');
                    card.className = 'item-card movie-card';
                    card.dataset.movieIndex = index;
                    card.tabIndex = 0; // Enfocable

                    // ... (creación de img, textContent como antes) ...
                    const imageContainer = document.createElement('div');
                    imageContainer.className = 'card-image-container';
                    const img = document.createElement('img');
                    const placeholderText = encodeURIComponent((movie.titulo || '?').charAt(0));
                    img.src = movie.imagen || `https://placehold.co/200x300/383838/aaaaaa?text=${placeholderText}`;
                    img.alt = '';
                    img.onerror = () => { img.src = `https://placehold.co/200x300/383838/aaaaaa?text=${placeholderText}`; img.alt = `Placeholder ${movie.titulo}`; };
                    img.loading = 'lazy';
                    imageContainer.appendChild(img);
                    const textContent = document.createElement('div');
                    textContent.className = 'text-content';
                    const title = document.createElement('h3');
                    title.textContent = movie.titulo;
                    textContent.appendChild(title);
                    card.appendChild(imageContainer);
                    card.appendChild(textContent);

                    card.addEventListener('click', () => navigateTo('playerView', { type: 'movie', index: index }));
                    fragment.appendChild(card);
                });
                moviesGridElement.appendChild(fragment);
            }

            // --- Lógica del Reproductor (Modificada para actualizar foco) ---
            function setupPlayerView(data) {
                // ... (lógica existente para configurar título, descripción, etc.) ...
                console.log("Configurando vista de reproductor para:", data);
                stopPlayback(); // Detiene cualquier reproducción anterior y limpia el foco del gamepad.

                playerContentTitle.textContent = 'Cargando...';
                playerContentDescription.textContent = '';
                playerFavoriteButton.style.display = 'none';
                playerSeriesSelectors.style.display = 'none';
                hlsPlayerElement.style.display = 'none';
                drivePlayerElement.style.display = 'none';
                showMessageInPlayer("Cargando...");


                if (data.type === 'tv') {
                    const channelIndex = data.index;
                    if (channelIndex >= 0 && channelIndex < tvChannels.length) {
                        const channel = tvChannels[channelIndex];
                        currentPlayingTvChannelIndex = channelIndex;
                        playerContentTitle.textContent = channel.title || 'Canal Desconocido';
                        playerContentDescription.textContent = channel.description || '';
                        setupTvPlayerControls(channelIndex); // Configura botón fav
                        playHlsStream(channel.url, channelIndex);
                        highlightPlayingChannel(channelIndex, tvChannelGridElement);
                        highlightPlayingChannel(channelIndex, favoritesChannelGridElement);
                    } else { /* ... error ... */ }
                } else if (data.type === 'series') {
                    const seriesIndex = data.index;
                    if (seriesIndex >= 0 && seriesIndex < seriesData.length) {
                        const serie = seriesData[seriesIndex];
                        currentPlayingSeries = { seriesIndex: seriesIndex, seasonNumber: null, episodeIndex: null };
                        playerContentTitle.textContent = serie.tituloSerie || 'Serie Desconocida';
                        playerContentDescription.textContent = serie.descripcion || '';
                        setupSeriesPlayerControls(serie); // Configura selectores
                        showMessageInPlayer("Selecciona temporada y episodio");
                    } else { /* ... error ... */ }
                } else if (data.type === 'movie') {
                    const movieIndex = data.index;
                    if (movieIndex >= 0 && movieIndex < moviesData.length) {
                        const movie = moviesData[movieIndex];
                        currentPlayingMovieIndex = movieIndex;
                        playerContentTitle.textContent = movie.titulo || 'Película Desconocida';
                        playerContentDescription.textContent = movie.descripcion || '';
                        playDriveStream(movie.urlDrive);
                    } else { /* ... error ... */ }
                } else { /* ... error ... */ }
                updateFocusableElementsForCurrentView(); // Actualizar foco para los controles del reproductor
            }
            function setupTvPlayerControls(channelIndex) { /* ... (sin cambios, pero playerFavoriteButton ya tiene tabindex="0") ... */ }
            function setupSeriesPlayerControls(serie) { /* ... (sin cambios, pero los select ya tienen tabindex="0") ... */ }
            function playHlsStream(url, channelIndex) { /* ... (sin cambios) ... */ }
            function handleHlsPlaying() { /* ... (sin cambios) ... */ }
            function handleVideoElementError(e) { /* ... (sin cambios) ... */ }
            function playDriveStream(url) { /* ... (sin cambios) ... */ }
            function stopPlayback() {
                // ... (lógica existente) ...
                if (gamepadFocusedElement && (gamepadFocusedElement === hlsPlayerElement || gamepadFocusedElement === drivePlayerElement)) {
                    setGamepadFocus(null); // Quitar foco si estaba en el video/iframe
                }
                currentPlayingTvChannelIndex = null;
                currentPlayingSeries = null;
                currentPlayingMovieIndex = null;
                highlightPlayingChannel(null, tvChannelGridElement);
                highlightPlayingChannel(null, favoritesChannelGridElement);
            }
            function showMessageInPlayer(message = "") { /* ... (sin cambios) ... */ }
            function hideMessageInPlayer() { /* ... (sin cambios) ... */ }

            // --- Favoritos TV ---
            function toggleTvFavorite(channelIndex) { /* ... (sin cambios) ... */ }
            function updateFavoriteButtonUI(channelIndex) { /* ... (sin cambios) ... */ }


            // --- Lógica del Gamepad ---
            function initGamepadControls() {
                window.addEventListener('gamepadconnected', (event) => {
                    console.log('Gamepad conectado:', event.gamepad.id);
                    if (activeGamepadIndex === null) {
                        activeGamepadIndex = event.gamepad.index;
                    }
                    if (!gamepadPollInterval) {
                        lastGamepadButtonStates = Array(event.gamepad.buttons.length).fill(false);
                        lastGamepadAxisStates = event.gamepad.axes.map(() => 0); // Simplificado
                        gamepadPollInterval = setInterval(pollGamepad, GAMEPAD_POLL_RATE);
                    }
                    updateFocusableElementsForCurrentView(); // Asegurar que el foco inicial esté listo
                });

                window.addEventListener('gamepaddisconnected', (event) => {
                    console.log('Gamepad desconectado:', event.gamepad.id);
                    if (activeGamepadIndex === event.gamepad.index) {
                        activeGamepadIndex = null;
                        clearInterval(gamepadPollInterval);
                        gamepadPollInterval = null;
                        setGamepadFocus(null); // Quitar foco visual
                    }
                });
                // Comprobar si ya hay gamepads conectados al inicio
                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i]) {
                        activeGamepadIndex = gamepads[i].index;
                        console.log('Gamepad ya conectado:', gamepads[i].id);
                        lastGamepadButtonStates = Array(gamepads[i].buttons.length).fill(false);
                        lastGamepadAxisStates = gamepads[i].axes.map(() => 0);
                        if (!gamepadPollInterval) {
                           gamepadPollInterval = setInterval(pollGamepad, GAMEPAD_POLL_RATE);
                        }
                        break;
                    }
                }
            }

            function pollGamepad() {
                if (activeGamepadIndex === null) return;
                const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
                const gp = gamepads[activeGamepadIndex];
                if (!gp) return;

                // Manejar botones (detectar solo el cambio de presionado)
                gp.buttons.forEach((button, index) => {
                    if (button.pressed && !lastGamepadButtonStates[index]) {
                        handleGamepadButtonPress(index);
                    }
                    lastGamepadButtonStates[index] = button.pressed;
                });

                // Manejar ejes (D-pad a menudo se mapea a ejes o botones)
                // Eje 0 (LX), Eje 1 (LY)
                const axisX = gp.axes[0];
                const axisY = gp.axes[1];

                // Movimiento horizontal
                if (axisX > GAMEPAD_AXIS_THRESHOLD && lastGamepadAxisStates[0] <= GAMEPAD_AXIS_THRESHOLD) {
                    moveGamepadFocus('right');
                } else if (axisX < -GAMEPAD_AXIS_THRESHOLD && lastGamepadAxisStates[0] >= -GAMEPAD_AXIS_THRESHOLD) {
                    moveGamepadFocus('left');
                }
                // Movimiento vertical
                if (axisY > GAMEPAD_AXIS_THRESHOLD && lastGamepadAxisStates[1] <= GAMEPAD_AXIS_THRESHOLD) {
                    moveGamepadFocus('down');
                } else if (axisY < -GAMEPAD_AXIS_THRESHOLD && lastGamepadAxisStates[1] >= -GAMEPAD_AXIS_THRESHOLD) {
                    moveGamepadFocus('up');
                }
                lastGamepadAxisStates[0] = axisX;
                lastGamepadAxisStates[1] = axisY;


                // Algunos gamepads mapean D-Pad a botones (ej. 12: Arriba, 13: Abajo, 14: Izquierda, 15: Derecha)
                // Esto es adicional al manejo de ejes para mayor compatibilidad.
                // Ya se maneja en handleGamepadButtonPress si están definidos como botones.
            }

            function handleGamepadButtonPress(buttonIndex) {
                console.log("Gamepad button pressed:", buttonIndex);
                if (loadingOverlay.classList.contains('visible')) return; // No hacer nada si está cargando

                if (errorOverlayCar.classList.contains('visible')) {
                    // Si el overlay de error está visible, solo permitir acción en sus botones
                    if (gamepadFocusedElement && errorOverlayCar.contains(gamepadFocusedElement)) {
                        if (buttonIndex === GAMEPAD_BUTTON_ACTION) {
                            gamepadFocusedElement.click();
                        }
                    }
                    return;
                }


                switch (buttonIndex) {
                    case GAMEPAD_BUTTON_ACTION: // 'A' o similar
                        if (gamepadFocusedElement) {
                            // Si el elemento enfocado es un select, el navegador debería abrirlo.
                            // Si es un input, enfocarlo para teclado virtual si es necesario.
                            if (gamepadFocusedElement.tagName === 'INPUT' && gamepadFocusedElement.type === 'text') {
                                gamepadFocusedElement.focus(); // Para que el teclado en pantalla aparezca si es relevante
                            } else {
                                gamepadFocusedElement.click();
                            }
                        }
                        break;
                    case GAMEPAD_BUTTON_BACK: // 'B' o similar
                        if (backButton.classList.contains('visible')) {
                            backButton.click();
                        }
                        break;
                    // Mapeo de D-Pad si viene como botones (común en muchos mandos)
                    case 12: moveGamepadFocus('up'); break;    // D-Pad Arriba
                    case 13: moveGamepadFocus('down'); break;  // D-Pad Abajo
                    case 14: moveGamepadFocus('left'); break; // D-Pad Izquierda
                    case 15: moveGamepadFocus('right'); break;// D-Pad Derecha
                }
            }

            function updateFocusableElementsForCurrentView(viewIdToUpdate = currentView) {
                if (gamepadFocusedElement) {
                    gamepadFocusedElement.classList.remove('gamepad-focus');
                    gamepadFocusedElement = null;
                }
                focusableElementsInView = [];
                let currentViewElement;

                if (errorOverlayCar.classList.contains('visible')) {
                    currentViewElement = errorOverlayCar;
                } else if (loadingOverlay.classList.contains('visible')) {
                     // No hay elementos enfocables en el overlay de carga
                    return;
                }
                else {
                    currentViewElement = views[viewIdToUpdate];
                }


                if (currentViewElement) {
                    // Seleccionar elementos que son naturalmente enfocables o tienen tabindex >= 0
                    // y son visibles.
                    const potentialElements = currentViewElement.querySelectorAll(
                        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                    );
                    potentialElements.forEach(el => {
                        // Comprobar si el elemento es visible y no está deshabilitado
                        if (el.offsetParent !== null && !el.disabled) {
                            focusableElementsInView.push(el);
                        }
                    });
                }


                if (focusableElementsInView.length > 0) {
                    // Intentar mantener el foco en un elemento similar si volvemos a una vista
                    // o si se actualiza la lista (ej. después de buscar)
                    let elementToFocus = focusableElementsInView[0]; // Por defecto el primero

                    // Lógica para restaurar foco (simplificada)
                    // Si estamos en una lista y hay un item activo, intentar enfocarlo
                    if ( (viewIdToUpdate === 'tvListView' || viewIdToUpdate === 'favoritesListView') && currentPlayingTvChannelIndex !== null) {
                        const activeCard = currentViewElement.querySelector(`.item-card[data-channel-index="${currentPlayingTvChannelIndex}"]`);
                        if (activeCard && focusableElementsInView.includes(activeCard)) {
                            elementToFocus = activeCard;
                        }
                    }
                    // Podría añadirse lógica similar para series y películas si se guarda el último reproducido.

                    setGamepadFocus(elementToFocus);
                }
            }


            function setGamepadFocus(element) {
                if (gamepadFocusedElement) {
                    gamepadFocusedElement.classList.remove('gamepad-focus');
                }
                gamepadFocusedElement = element;
                if (gamepadFocusedElement) {
                    gamepadFocusedElement.classList.add('gamepad-focus');
                    // Asegurarse de que el elemento enfocado esté visible en el scroll
                    gamepadFocusedElement.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                }
            }

            function moveGamepadFocus(direction) {
                if (!gamepadFocusedElement || focusableElementsInView.length === 0) {
                    if (focusableElementsInView.length > 0) setGamepadFocus(focusableElementsInView[0]);
                    return;
                }

                let currentIndex = focusableElementsInView.indexOf(gamepadFocusedElement);
                if (currentIndex === -1) { // Si el elemento enfocado no está en la lista (raro)
                     setGamepadFocus(focusableElementsInView[0]);
                     return;
                }

                let nextIndex = currentIndex;
                const currentElement = focusableElementsInView[currentIndex];
                const parentGrid = currentElement.closest('.item-grid, .channel-grid, .menu-grid, .error-buttons');

                if (parentGrid) { // Navegación en cuadrícula
                    const items = Array.from(parentGrid.querySelectorAll('[tabindex="0"]:not([disabled])'))
                                     .filter(el => el.offsetParent !== null); // Solo visibles
                    if (!items.length) return;

                    currentIndex = items.indexOf(currentElement);
                    if (currentIndex === -1) { // Si el elemento actual no está en la rejilla visible, enfocar el primero.
                        setGamepadFocus(items[0]);
                        return;
                    }

                    const firstItemRect = items[0].getBoundingClientRect();
                    const currentItemRect = currentElement.getBoundingClientRect();
                    // Estimar columnas (puede no ser perfecto para auto-fit si los anchos varían mucho)
                    let numCols = 0;
                    if (items.length > 1 && firstItemRect.width > 0) {
                        // Contar cuántos elementos caben en la primera fila visiblemente
                        let currentY = items[0].getBoundingClientRect().top;
                        for(let i = 0; i < items.length; i++) {
                            if (items[i].getBoundingClientRect().top === currentY) {
                                numCols++;
                            } else {
                                break;
                            }
                        }
                         if (numCols === 0 && parentGrid.offsetWidth > 0 && firstItemRect.width > 0) { // Fallback
                            numCols = Math.max(1, Math.floor(parentGrid.offsetWidth / (firstItemRect.width + parseFloat(getComputedStyle(items[0]).marginLeft) + parseFloat(getComputedStyle(items[0]).marginRight) ) ));
                         }

                    }
                     if (numCols === 0) numCols = 1; // Evitar división por cero

                    switch (direction) {
                        case 'left':
                            if (currentIndex % numCols !== 0) nextIndex = currentIndex - 1;
                            else nextIndex = currentIndex + (numCols - 1); // Wrap around a la derecha de la misma fila (si es posible)
                            if (nextIndex >= items.length) nextIndex = items.length -1; // No pasar del final
                            if (items[nextIndex].getBoundingClientRect().top !== currentItemRect.top && currentIndex % numCols === 0) { // Si al wrappear cambia de fila, no wrappear
                                nextIndex = currentIndex;
                            }

                            break;
                        case 'right':
                            if ((currentIndex + 1) % numCols !== 0 && currentIndex + 1 < items.length) nextIndex = currentIndex + 1;
                            else nextIndex = currentIndex - (numCols - 1); // Wrap around a la izquierda
                            if (nextIndex < 0) nextIndex = 0; // No pasar del inicio
                             if (items[nextIndex].getBoundingClientRect().top !== currentItemRect.top && (currentIndex + 1) % numCols === 0) {
                                nextIndex = currentIndex;
                            }
                            break;
                        case 'up':
                            if (currentIndex - numCols >= 0) nextIndex = currentIndex - numCols;
                            break;
                        case 'down':
                            if (currentIndex + numCols < items.length) nextIndex = currentIndex + numCols;
                            else { // Si no hay exactamente debajo, ir al último de la siguiente "fila" visual o al último item
                                nextIndex = Math.min(items.length - 1, currentIndex + (numCols - (currentIndex % numCols)) );
                                if (nextIndex <= currentIndex) nextIndex = items.length - 1; // Ir al último si no hay más abajo
                            }
                            break;
                    }
                     if (nextIndex >= 0 && nextIndex < items.length) {
                        setGamepadFocus(items[nextIndex]);
                    }

                } else { // Navegación lineal simple
                    switch (direction) {
                        case 'up': case 'left':
                            nextIndex = (currentIndex - 1 + focusableElementsInView.length) % focusableElementsInView.length;
                            break;
                        case 'down': case 'right':
                            nextIndex = (currentIndex + 1) % focusableElementsInView.length;
                            break;
                    }
                     if (nextIndex >= 0 && nextIndex < focusableElementsInView.length) {
                        setGamepadFocus(focusableElementsInView[nextIndex]);
                    }
                }
            }


            // --- Event Listeners (Existentes, sin cambios mayores) ---
            backButton.addEventListener('click', () => { /* ... */ });
            document.querySelectorAll('#mainMenuView .menu-button').forEach(button => { /* ... */ });
            if (tvSearchButton && tvSearchInput) { /* ... */ }
            closeErrorCarButton.addEventListener('click', hideError);


            // --- Inicialización ---
            function initializeApp() {
                console.log("Inicializando aplicación táctil con Gamepad...");
                initGamepadControls(); // Inicializar Gamepad
                navigateTo('mainMenuView'); // Esto llamará a updateFocusableElementsForCurrentView
            }

            initializeApp();

        }); // Fin DOMContentLoaded
    } catch (globalError) {
        // ... (Manejo de error global existente) ...
        console.error("Error global no capturado:", globalError);
        const body = document.body;
        if (body) {
            body.innerHTML = `
                <div style="color: white; background-color: #121212; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 20px; font-family: sans-serif;">
                    <h1>Oops! Algo salió muy mal.</h1>
                    <p>Se ha producido un error crítico al cargar la aplicación.</p>
                    <p>Por favor, intenta recargar la página o contacta al administrador.</p>
                    <p style="font-size: 0.8em; color: #b3b3b3; margin-top: 20px;">Detalles del error (consola): ${globalError.message}</p>
                </div>
            `;
        } else {
            alert("Error crítico al cargar la aplicación. Por favor, recarga.");
        }
    }
    </script>
</body>
</html>
